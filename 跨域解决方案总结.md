## 跨域解决方案总结

> **跨域是浏览器的行为，不同源的 http 请求都是不被允许的，不被允许的意思是，浏览器还是会发出这个请求，但是它会拦截响应内容，如果发现响应 header 中"Access-Control-Allow-Origin"设置的允许访问的源没有包含当前源，则拒绝将数据返回给当前端**

1. 通过 jsonp 跨域
2. document.domain + iframe 跨域
3. location.hash + iframe
4. window.name + iframe 跨域
5. postMessage 跨域
6. 跨域资源共享（CORS）
7. nginx 代理跨域
8. nodejs 中间件代理跨域
9. WebSocket 协议跨域

## jsonp 跨域

> 原理：通常为了减轻 web 服务器的负载，我们把 css，image，js 等资源放在另外一台独立域名的服务器，然后在 html 上通过 img,script, style 标签在不同的域名加载静态资源，这种行为被浏览器允许，借此，我们可以通过动态创建 script 标签，再带上一个带参数的网址,去访问该网站的接口不被跨域拦截，实现跨域通信。

原生 js 代码:

```
var script =document.createElement('script');
script.type='text/javascript'
script.src='www.example.com/login?user=xxx&psw=xxx&callback=onCallback';
window.document.head.appendChild(script);//通过这一步发起请求
function onCallback(res){
    console.log(res)
}
```

- jquery 跨域请求与 ajax 一样，只需设置 dataType='jsonp'
- vue 跨域请求使用 this.\$http.jsonp();

> 缺点：只能使用 get 方法，并且请求是同步的

## 服务器代理

1.  正向代理，与你页面同源的服务器向代替你向不同源的服务器发起请求并返回给你，因为前端是向同源服务器发送请求的，所以不存在跨域问题
2.  反向代理，使用 nginx 反向代理，将你请求的不同源的服务接口映射到一个同源的地址，然后你向这个同源的地址发送请求

## document.domain+iframe 跨域

此方案仅限于主域相同子域不同的场景如 www.example.com 与 vip.example.com

> 原理：两个界面通过 js 强行设置 document.domain 为基础主域，就实现了跨域

实现代码如下：

1. 父窗口 www.example.com

```
<iframe src='http://vip.example.com'></iframe>
document.domain='example.com'
var user='www'
```

2. 子窗口 vip.example.com

```
document.domain='example.com'
alert(window.parent.user)
```

## local.hash + iframe 跨域

> 原理：a 想要和 b 跨域通信，通过中间页面 c 来实现，三个页面，利用不同域之间 iframe 的 localtion.hash 来传值，相同域直接通过 js 的 parent.parent 来访问
> 具体实现：A 域: a.html,B 域: b.html,A 域: c.html。a 与 b 页面不同域只能通过 hash 来传值，而 b 与 c 页面不同域名只能通过 hash 来传值，但是 c 与 a 页面同域可以通过 parent.parent 来访问

代码 www.A.com a.html

```
<iframe id='iframe' src='http://www.B.com/b.html'></iframe>
var iframe=document.getElementById('iframe')
setTimeout(function(){
    iframe.src=iframe.src+'这是a页面传给b页面的值'
},1000)

function callback(data){
  console.log(`c页面把b页面传来的值通过parent.parent传给a页面:${data}`)
}
```

代码 www.B.com b.html

```
<iframe id='iframe' src='http://www.A.com/c.html'></iframe>
var iframe=document.getElementById('iframe')
//监听a.html界面改变src时，当前页面location.hash改变
window.onhashchange(){
    console.log(`当前的location.hash因为a.html界面setTimeout改变了`)
    iframe.src=iframe.src+'这是b页面传给c页面的值';//这一步是把值传给c页面
}

```

代码 www.A.com c.html

```
//监听b页面src改变后，当前页面location.hash改变
window.onhashchange(){
    console.log(`当前的location.hash因为a.html界面setTimeout改变了`)
    window.parent.parent.callback('这是b页面传给c页面的值，现在传给a页面')//
}

```

## window.name + iframe 跨域

> 原理：window.name 属性的独特之处，name 值在不同页面甚至是不同的域加载后依然存在，并且可以保存很长的值（2M）

1. 代码 www.A.com a.html

```
var proxy=function(url,callback){
    var state=0;
    var iframe=document.createElement('iframe');
    //加载跨域界面
    iframe.src=url;
     // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload=function(){
      if(state==0){
          // 第1次onload(跨域页)成功后，切换到同域代理页面
         state=1;
         iframe.contentWindow.location='[传值啊啊啊'](http://www.domain1.com/proxy.html')
      }

      if(state==1){
          // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
        callback(iframe.contentWindow.name)
        destoryIframe(iframe)
      }
    }
    document.body.appendChild(iframe);
    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryIframe(){
        iframe.contentWindow.document.write('')
        iframe.contentWindow.close()
        document.body.removeChild(iframe)
    }
}
//请求跨域界面b.html的window.name属性的值
proxy('http://www.B.com/b.html')

```

2. www.A.com proxy.html
   中间代理页面，这个页面为空就行了，但必须与 a.html 同域 3.代码 www.B.com b.html

```
window.name='这是b页面的name值，可以床给a.html'
```

[未完待续++]('https://www.cnblogs.com/roam/p/7520433.html')
