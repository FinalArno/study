# 常见 web 安全攻防总结

## 1，XSS（Cross site script）攻击

> XSS 的工作原理是攻击者往 web 页面里面插入恶意可执行脚本代码，当用户浏览该页面，嵌入其中的脚本代码就会执行，从而达到可以盗取用户信息的目的

XSS 的攻击大致可以分为以下几种：

### 非持久型 XSS

> 非持久型 XSS 漏洞，也叫反射型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。

举个栗子，比如你的 web 页面有以下代码

```html
<select>
  <script>
    document.write(
      "" +
        "<option value=1>" +
        location.href.substring(location.href.indexOf("default=") + 8) +
        "</option>"
    );
    document.write("<option value=2>English</option>");
  </script>
</select>
```

这样攻击者就可以通过 url（**类似http://www.xxx.com/defalut=\<script>alert(document.cookie) \</script>**）来注入可执行脚本

非持久型 XSS 攻击有以下特点：

1. 即时性，不经过服务器存储，直接通过 http 的 get 和 post 就能完成一次攻击拿到用户数据
2. 攻击者需要诱骗点击
3. 反馈率低，所以较难发现和响应修复
4. 盗取用户保密信息

### 防范手段

1. web 渲染的所有内容以及数据必须来源于服务器
2. 尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染
3. 尽量不要使用 eval()， new Function(),document.write(),document.writeIn(),window.setInterval(),window.setTimeout(),innerHTML,document.createElement()等可执行字符串的方法
4. 如果做不到以上几点，那么也必须对涉及 DOM 渲染的方法传入的字符串进行**escape**转义
5. 前端渲染的时候任何的字段都要做**escape**转义编码,js 原生函数 escape()可以直接使用
   > escape 转义的目的是将一些构成 HTML 标签的元素转义，比如<,>,空格等转义成<,> ,等显示转义字符。很多开源工具都可以协助我们做 escape 转义

### 持久型 XSS 攻击

持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 form 表单提交等交互功能，如发表留言，提交文本信息等，黑客利用 xss 漏洞，将脚本通过正常功能提交到后台进入数据库长久保存，当前端页面获取后端从数据库获取的脚本代码时，恰好将其渲染
主要注入页面方式和非持久型 xss 攻击类似，只不过持久型不是来源于 url，而是来源于后端从数据库中读取出来的数据，持久型 xss 攻击不需要诱骗用户点击，黑客只需要通过正常的表单提交注入即可，但是这种注入的成本也是比较高的

### **攻击需要满足以下条件**

1. post 请求提交表单后端没有做转义直接入库
2. 后端从数据库取出数据后不转义直接返回给前端
3. 前端获取后端数据后不转义直接渲染成 DOM

### 持久型 xss 攻击有以下特点

1. 持久性，植入在数据库中
2. 危害面广，甚至可以让用户机器变成 DDos 攻击的肉鸡
3. 盗取用户私密信息

### **为防止持久型 XSS 攻击，前后端需共同努力**

1. 后端在入库前应该选择不信任前端的任何数据，将所有的字段统一进行转义处理
2. 后端在输出给前端数据是统一做转义处理
3. 前端在渲染页面 DOM 的时候选择不相信后端的任何数据，统一做转义处理

### 基于字符集的 XSS 攻击

基于字符集的 XSS
        其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。

以基于 utf-7 的 XSS 为例
       utf-7 是可以将所有的 unicode 通过 7bit 来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。
        这个字符集为了通过 7bit 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。

```javascript
<script>alert("xss")</script>
```

可以被解释为：
+ADw-script+AD4-alert(+ACI-xss+ACI-)+ADw-/script+AD4-
可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。

### 所以我们有什么办法避免这种 XSS 呢 ?

1. 记住指定 <meta charset="utf-8">
2. XML 中不仅要指定字符集为 utf-8，而且标签要闭合
3. 牛文推荐：http://drops.wooyun.org/papers/1327 （这个讲的很详细）

### 基于 Flash 的跨站 XSS

基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，虽然现在开发 ActionScript 的产品线几乎没有了，但还是提一句吧，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作 cookie
避免方法 :

1. 严格管理 cookie 的读写权限
2. 对 Flash 能接受用户输入的参数进行过滤 escape 转义处理

### 未经验证的跳转 XSS

有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做 302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。

### 这时候需要通过以下方式来防止这类漏洞 :

1. 对待跳转的 URL 参数做白名单或者某种规则过滤
2. 后端注意对敏感信息的保护, 比如 cookie 使用来源验证。

## CSRF(跨域请求伪造攻击)

跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

### 1. 攻击细节：

跨站请求攻击，就是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息甚至财产转移和购买商品等等），由于浏览器曾经认证过，所有被访问的网站认为是用户在操作而去运行。这利用了 web 中用户身份验证的一个漏洞：**简单的身份验证只能保证是某个用户的浏览器，而不能保证是用户本人在操作**
举个栗子：

- 假如某家银行的转账请求是 GET，请求 URL 是http://www.xxx.com/withDraw?user=AAA&money=10000&for=BBB;
- 那么攻击者就可以在另外一个网站放上以上代码（可以通过在一个常用的授信网站上传图片）：\<img src='http://www.xxx.com/withDraw?user=AAA&money=10000&for=CCC'>
- 如果有账户名为 AAA 的用户登陆了该银行的网站，期间有访问了带有 CSRF 攻击的恶意网站，那么这个恶意网站就会去请求图片资源，这是就会调用http://www.xxx.com/withDraw?user=AAA&money=10000&for=CCC GET 方法，那么由于该银行网站判断是该用户的标准仅仅是通过 cookie 来校验，那么该请求就会发送成功，这时该用户就会少了 10000；
- 这种恶意的网站可以有很多种形式，例如可以放在论坛，博客等任何用户生成内容的网站中（即用户可以提交脚本代码并显示在论坛或者博客中），攻击者也不需要控制防止恶意代码的网站，这样就意味着用户即使是访问可信的网站，在没有防护措施的情况下也会有受到攻击的危险。
- 通过栗子可以看出，攻击者并不能通过 CSRF 来获取用户的信息以及获取用户的控制权，他们能做到的是欺骗用户浏览器，让它以用户的名义发送请求。

### 防范措施

1. 检查**Referer**字段
   Http 请求头中有一个 Referer 字段，这个字段用以表明请求来源于哪个网站（当前发起请求的页面 url，Origin 字段是当前请求接口网站的首页），在处理敏感数据请求的时候，通常来说，Referer 字段应该于请求地址是同一个字段。所以，服务端只需要判断请求头的 Referer 字段所在的网页是否与对应的网站相同则可避免恶意的访问。
   > 这种方法简单，工作量低，只需要在关键的访问处增加校验。但也有他的局限性，因为此方法完全依赖浏览器发送正确的 Referer 字段，如果攻击者攻击浏览器篡改了 Referer 字段那么则无法保证请求的真实性。
2. 添加校验 **Token**
   由于 CSRF 的本质是欺骗浏览器去访问攻击者预设的地址，那么在用户访问敏感数据的时候，要求浏览器提供不保存在 Cookie 中的，并且攻击者无法伪造的校验数据就可以阻止攻击者进行 CSRF 攻击。token 一般是服务器产生的一个随机字符串，在用户登陆的时候返回给用户并保存在本地（localstorage），然后发送请求的时候附带 token，如果浏览器检测到错误的 token 或者未带 token （由于攻击者无法事先得知这个值）则拒绝该请求。

## SQL 注入

> SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。
> 而造成 SQL 注入的原因是因为程序没有有效的转义过滤用户的输入，使攻击者成功的向服务器提交恶意的 SQL 查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。

很多 Web 开发者没有意识到 SQL 查询是可以被篡改的，从而把 SQL 查询当作可信任的命令。殊不知，SQL 查询是可以绕开访问控制，从而绕过身份验证和权限检查的。更有甚者，有可能通过 SQL 查询去运行主机系统级的命令。
